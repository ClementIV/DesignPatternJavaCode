## 工厂方法模式
---
### 现有问题

* 简单工厂模式虽然简单，但是存在一个很严重的问题。当系统中需要引入新产品时，由于静态工厂方法通过所传入的参数的不同来创建不同的产品，这必定要修改工厂类的源代码。违背“开闭原则”

### 解决思路
* 采用工厂方法模式

### 日志记录器的设计

### 工厂方法模式概述

 * 在简单工厂模式中只提供一个工厂类，该工厂类处于对产品类进行实例化的中心位置，它需要知道每一个产品对象的创建细节，并决定何时实例化哪一个产品类。
 
 * 工厂方法模式（Factory Method Pattern）：**定义一个用于创建对象的接口，让子类决定使用哪一个类实例化。**
    * 工厂方法模式让一个类的实例化延迟到其子类。
    * 工厂方法模式又简称 **工厂模式（Factory Pattern）**
    * 又称**虚拟构造器模式（Vitrual Constructor Pattern）**
    * 又称**多态工厂模式 （Polymorphic Factory Pattern）** 

### 包含的角色

* Product(抽象产品)： 定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。
* ConcreteProduct(具体产品)：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。
* Factory(抽象工厂)：在抽象工厂类中，声明了工厂方法（Factory Method),用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。
* ConcreteFactory(具体工厂)：它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，可有客户端调用，返回一个具体产品类的实例。

引入抽象工厂角色典型代码如下：

```
interface Factory {
    public Product factoryMethod();
}
```

抽象工厂中声明了工厂方法但并未实现工厂方法，具体的对象的创建由其子类负责、

```

Class ContcreteFactory implements Factory{
    public Prouduct factoryMethod(){
        return new ConcreteProduct();
    }
}
```

具体的使用方法

```
Factory factory ;
factory = new ConcreteFactory();
Product product;
product = factory.factoryMethod();

```